import type { PlopTypes } from "@turbo/gen";

import { exec } from "node:child_process";
import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";
import { promisify } from "node:util";
import axios from "axios";
import { get } from "es-toolkit/compat";

const execPromise = promisify(exec);

type TokenValue = string | number | boolean | null;

interface TokenObject {
  [key: string]: TokenValue | TokenObject;
}

/**
 * Token generator
 * Fetches design tokens from GitHub and generates a TypeScript file
 */
export default function tokenGenerator(plop: PlopTypes.NodePlopAPI): void {
  plop.setGenerator("token", {
    description: "Fetch design tokens from GitHub and generate TypeScript file",
    prompts: [
      {
        type: "input",
        name: "tokenUrl",
        message: "Token source URL:",
        default:
          "https://raw.githubusercontent.com/KRDS-uiux/krds-uiux/main/tokens/transformed_tokens.json",
      },
      {
        type: "input",
        name: "outputPath",
        message: "Output file path:",
        default: "packages/krds/src/design-tokens/tokens.ts",
      },
    ],
    actions: [
      // * Generate token.ts file
      async (answers) => {
        const { tokenUrl, outputPath } = answers as {
          tokenUrl: string;
          outputPath: string;
        };
        try {
          const outputAbsolutePath = path.join(
            plop.getDestBasePath(),
            outputPath,
          );

          console.log("ðŸ”„ Fetching token file...");

          // Fetch token file from GitHub
          const response = await axios.get(tokenUrl);
          if (response.status !== 200) {
            throw new Error(
              `Cannot fetch tokens from GitHub: ${response.status} ${response.statusText}`,
            );
          }

          const tokensJson = response.data as TokenObject;

          console.log("âœ… Successfully fetched token file.");
          console.log("ðŸ”„ Converting reference values to actual values...");

          // Convert all reference values ({key}) in the token object to actual values
          const resolvedTokens = resolveTokenReferences(tokensJson);

          console.log("âœ… Reference value conversion completed.");
          console.log("ðŸ”„ Creating TypeScript file...");

          // Convert to TypeScript file and save
          const tsContent = `// This file is automatically generated. Do not modify directly.
// Generated at: ${new Date().toISOString()}

const TOKENS = ${JSON.stringify(resolvedTokens, null, 2)} as const;

export default TOKENS;
`;

          // Check and create output directory
          const outputDir = path.dirname(outputAbsolutePath);
          try {
            await mkdir(outputDir, { recursive: true });
          } catch (_) {
            console.log(`ðŸ“‚ Output directory already exists: ${outputDir}`);
          }

          // Save file with promises API
          await writeFile(outputAbsolutePath, tsContent);

          console.log(
            `âœ… Token file successfully created: ${outputAbsolutePath}`,
          );
          return "Token file generation completed successfully";
        } catch (error) {
          console.error("âŒ Error occurred during token generation:", error);
          throw error;
        }
      },

      // * Format the generated file with Biome
      async (answers) => {
        const { outputPath } = answers as { outputPath: string };
        const outputAbsolutePath = path.join(
          plop.getDestBasePath(),
          outputPath,
        );

        try {
          console.log("ðŸ”„ Formatting with Biome...");
          const { stderr } = await execPromise(
            `pnpx @biomejs/biome format --write "${outputAbsolutePath}"`,
          );

          if (stderr) {
            console.warn(`âš ï¸ Biome formatting warning: ${stderr}`);
          } else {
            console.log("âœ… Biome formatting completed successfully.");
          }
          return "Biome formatting completed successfully";
        } catch (formatError) {
          console.error("âš ï¸ Failed to format with Biome:", formatError);
          console.log("ðŸ“ Token file was generated but not formatted.");
          return "Failed to format with Biome, but token generation was successful";
        }
      },
    ],
  });
}

/**
 * Convert reference values ({key}) in token object to actual values (key.value)
 */
function resolveTokenReferences(tokens: TokenObject): TokenObject {
  const resolvedTokens = JSON.parse(JSON.stringify(tokens)) as TokenObject;

  // Iterate through all token values to find reference pattern {key}
  const processObject = (obj: TokenObject): TokenObject => {
    for (const key in obj) {
      if (typeof obj[key] === "object" && obj[key] !== null) {
        processObject(obj[key] as TokenObject);
      } else if (
        typeof obj[key] === "string" &&
        (obj[key] as string).match(/^{([^}]+)}$/)
      ) {
        // Extract {key} pattern
        const refKey = (obj[key] as string).slice(1, -1);
        // Replace reference with key.value
        obj[key] = get(resolvedTokens, `${refKey}.value`) as TokenValue;
      }
    }
    return obj;
  };

  return processObject(resolvedTokens);
}
